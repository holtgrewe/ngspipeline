#!/usr/bin/env nextflow

import CopyHelper
import ChannelUtil
import FastQC
import PathUtil

// Uncomment for seeing the output of the processes.
if (params.verbose)
    echo true

println ">>> NGS Pipeline"
println ">>>"
println ">>> up to checkpoint  ${params.runUpToCheckpoint}"
println ">>> base directory    ${params.baseDir}"
println ">>> wetlab ID         ${params.runID}"

// Create helper for copying files.
copyHelper = new CopyHelper(params.baseDir, params.printCopyMsgs)

// Open channel for left and right files and merge it into triples, the
// first entry is the LCS of the file names that can be used as a read
// pair identifier.
readPairs = ChannelUtil.createFilePairChannel(
        params.runID,
        Channel.fromPath([params.baseDir, "fastq", "original", "*_R1*.fastq*"].join(File.separator)),
        Channel.fromPath([params.baseDir, "fastq", "original", "*_R2*.fastq*"].join(File.separator)),
        )

// Genome file.
genomeFile = file(params.genome)

// Duplicate the read pairs into one queue for runFastQCOriginal
// and runTrimming.
(readPairsFastQCOriginal,
 readPairsRunTrimming) = readPairs.separate(2) { x -> [x, x] }

// --------------------------------------------------------------------------
// Run FastQC on the original reads.
// --------------------------------------------------------------------------

process runFastQCOriginal {
    cpus params.fastqc.cpus
    module 'fastqc/0.11.2'

    input:
    set runID, file(readL), file(readR) from readPairsFastQCOriginal

    output:
    set file('*.zip'), file('*.html') into fastqcOutputOriginal

    script:
    """
    set -x
    fastqc -t ${params.fastqc.cpus} -o . ${readL} ${readR}
    """
}

copyHelper.copyFiles(fastqcOutputOriginal, "reports/fastqc-original");

// --------------------------------------------------------------------------
// Run read trimming on the original reads
// --------------------------------------------------------------------------

process runTrimming {
    cpus params.skewer.cpus
    module "skewer/0.1.120"

    input:
    set runID, file(readL), file(readR) from readPairsRunTrimming

    output:
    set runID, file("out/${readL}"), file("out/${readR}") into readPairsTrimmed
    set file("*.log") into trimmingLogs

    script:
    """
    set -x
    # call Skewer
    skewer -x ${params.skewer.adaptersR1} -y ${params.skewer.adaptersR2} -m pe -z -t ${params.skewer.cpus} ${readL} ${readR}
    # compute name of left/right Skewer result file
    NAMEBASE=${readL}
    LEFT=\${NAMEBASE%.gz}-trimmed-pair1.fastq.gz
    RIGHT=\${NAMEBASE%.gz}-trimmed-pair2.fastq.gz
    # move Skewer output to expected file names
    mkdir -p out
    mv \${LEFT} out/${readL}
    mv \${RIGHT} out/${readR}
    """
}

// Duplicate the read pairs into multiple queues for processing / copying out.
(readPairsFastQCTrimmed,
 readPairsRunMapping,
 readPairsTrimmedCopyOut) = readPairsTrimmed.separate(3) { x -> [ x, x, x ] }

// Copy out results from trimming step (map removes the pair).
copyHelper.copyFiles(trimmingLogs, "reports/trimming");
copyHelper.copyFiles(readPairsTrimmedCopyOut.map { [it[1], it[2]] }, "fastq/trimmed");

// --------------------------------------------------------------------------
// Run FastQC on the trimmed reads.
// --------------------------------------------------------------------------

process runFastQCTrimmed {
    cpus params.fastqc.cpus
    module 'fastqc/0.11.2'

    input:
    set runID, file(readL), file(readR) from readPairsFastQCTrimmed

    output:
    set file('*.zip'), file('*.html') into fastqcOutputTrimmed

    script:
    """
    set -x
    fastqc -t ${params.fastqc.cpus} -o . ${readL} ${readR}
    """
}

copyHelper.copyFiles(fastqcOutputTrimmed, "reports/fastqc-trimmed");

if (params.runUpToCheckpoint <= 1)
	return;

// --------------------------------------------------------------------------
// Run Read Mapping
// --------------------------------------------------------------------------

// The alignments are written to the temporary files alignment.bam. These
// BAM files are already sorted.

// BWA-MEM variant
process runReadMapping {
    cpus params.bwa.total.cpus
    module "bwa/0.7.10"
    module "samtools/1.1"

    input:
    genomeFile
    set runID, readL, readR from readPairsRunMapping

    output:
    set file('alignment.bam') into bamFiles

    """
    set -x
    bwa mem -R '@RG\\tID:${runID}\\tSM:${runID}\\tPL:${params.runPlatform}' -t ${params.bwa.mapping.cpus} ${genomeFile} ${readL} ${readR} | samtools view -Sb -u - | samtools sort -@ ${params.bwa.sorting.cpus} -m 1G - alignment
    """
}

// --------------------------------------------------------------------------
// Merge Reads and Mark Duplicates
// --------------------------------------------------------------------------

// TODO(holtgrew): We inject the runID name here since we cannot use global variables in input files yet (bug #18).
jointBams = bamFiles.map{f -> [params.runID, f] }.groupTuple()  // concatenate these files

process runMergeAndMarkDuplicates {
    cpus params.bamPostproc.cpus
    module "samtools/1.1"
    module "picard-tools/1.125"

    input:
    set runID, bamFiles from jointBams

    output:
    file("${runID}.mkdup.*") into markedAlignmentsOut
    set runID, file("${runID}.mkdup.bam"), file("${runID}.mkdup.bai") into markedAlignments
    """
    #!/bin/bash
    set -x
    # count number of files, merge multiple files and copy single file
    FILES="${bamFiles.join(" ")}"
    FILES=( \$FILES )
    if [[ \${#FILES[@]} -gt 1 ]]; then
        samtools merge -f merged.bam ${bamFiles.join(" ")}
    else
        cp \${FILES} merged.bam
    fi
    # fix header, prepend "@HD\tVN:1.5\tSO:coordinate", since samtools does not do so.
    echo -e "@HD\tVN:1.5\tSO:coordinate" > header.sam
    samtools view -H merged.bam >> header.sam
    samtools reheader header.sam merged.bam > ${runID}.bam
    # mark duplicates
    java -Xmx32G picard.sam.markduplicates.MarkDuplicates INPUT=${runID}.bam OUTPUT=${runID}.mkdup.bam METRICS_FILE=${runID}.mkdup.metrics CREATE_INDEX=true
    """
}

copyHelper.copyFiles(markedAlignmentsOut, "bam");

(markedAlignmentForCoverage,
 markedAlignmentForQualimap,
 markedAlignmentForVariantCalling) = markedAlignments.separate(3) { x -> [ x, x, x ] }

// --------------------------------------------------------------------------
// Run BAM Coverage Tools on finalBAM
// --------------------------------------------------------------------------

process runCoverageAnalysis {
    cpus 1
    module "samtools/1.1"
    module "picard-tools/1.125"
    module "bedtools2/2.22.0"

    input:
    set runID, file(bamFile), file(baiFile) from markedAlignmentForCoverage

    output:
    file("${runID}.*") into coverageReportOut

    script:
    """
    set -x
    # create output directory
    mkdir -p out
    # create coverage report
    ${params.pipelineDir}/scripts/statistics.pl -r ${params.ccdsBED} -b ${bamFile} -o ${runID} -d 
    """
}

copyHelper.copyFiles(coverageReportOut, "reports/coverage")

// --------------------------------------------------------------------------
// Run Qualimap on finalBAM
// --------------------------------------------------------------------------

process runQualimap {
    cpus params.qualimap.cpus
    module "qualimap/2.0"

    input:
    set runID, file(bamFile), file(baiFile) from markedAlignmentForQualimap

    output:
    file("${runID}.zip") into qualimapReportOut

    script:
    """
    set -x
    # create output directory
    mkdir ${runID}
    # create quality report with Qualimap
    qualimap bamqc --java-mem-size=10G -c -gd HUMAN -os -nt ${params.cpus.qualimap} -gff ${params.ccdsBED} -bam ${bamFile} -outdir ${runID}
    # zip output directory for copying out
    zip -r ${runID}.zip ${runID}
    """
}

copyHelper.copyFiles(qualimapReportOut, "reports/qualimap", true)

if (params.runUpToCheckpoint <= 2)
	return;

if (params.caller == "freebayes") {

// --------------------------------------------------------------------------
// Run Variant Calling on Postprocessed BAM File
// --------------------------------------------------------------------------

process runVariantCalling {
    cpus params.freebayes.cpus
    module 'freebayes/0.9.20'
    module 'vcflib'  // currently not versionized :(

    input:
    genomeFile
    set runID, file(bamFile), file(baiFile) from markedAlignmentForVariantCalling

    output:
    file "*.vcf" into vcfOut

    script:
    """
    set -x
    # call variants in parallel
    freebayes-parallel <(fasta_generate_regions.py ${genomeFile}.fai 100000) ${params.freebayes.cpus} -f ${genomeFile} ${bamFile} >tmp/${params.runID}.vcf
    # introduce contig=<..> fields into the header
    mkdir -p tmp
    awk '/^@SQ/ { print "##contig=<ID="substr(\$2, 4) ",length" substr(\$3,4) ",md5=" substr(\$5,4) ">"}' ${params.genomeDict} > tmp/contigs_header.vcf
    grep '^#' tmp/${params.runID}.vcf > tmp/${params.runID}.vcf
    cat contigs_header.vcf >> tmp/${params.runID}.vcf
    grep -v '^#' tmp/${params.runID}.vcf >> ${params.runID}.vcf
    """
}

copyHelper.copyFiles(vcfOut, "vcf");

} else { // if (params.caller == "freebayes")

// --------------------------------------------------------------------------
// Run BAM Realignment
// --------------------------------------------------------------------------

// Note that we are using time before the java commands below because
// otherwise, we do not get a per-command time report.

process runBAMRealignment {
 cpus params.gatk.bamPostproc.cpus
 module 'gatk/3.3-0'

 input:
 set runID, file(bamFile), file(baiFile) from markedAlignmentForVariantCalling

 output:
 set file("${bamFile}.intervals"), file("${runID}.mkdup.ra.*") into realignedOut
 set runID, file("${runID}.mkdup.ra.bam"), file("${runID}.mkdup.ra.bai") into realigned

 """
 set -x
 # create realignment target intervals
 time java -Xmx8g org.broadinstitute.gatk.engine.CommandLineGATK -T RealignerTargetCreator -R ${genomeFile} --known ${params.oneKGenomes} --known ${params.mills} -nt ${params.gatk.bamPostproc.cpus} -I ${bamFile} -o ${bamFile}.intervals
 # perform indel realignment
 time java -Xmx8g org.broadinstitute.gatk.engine.CommandLineGATK -T IndelRealigner -R ${genomeFile} -known ${params.oneKGenomes} -known ${params.mills} -I ${bamFile} -o ${runID}.mkdup.ra.bam --targetIntervals ${bamFile}.intervals
 """
}

copyHelper.copyFiles(realignedOut, "bam");

// --------------------------------------------------------------------------
// Run BAM Recalibration
// --------------------------------------------------------------------------

// Note that we are using time before the java commands below because
// otherwise, we do not get a per-command time report.

process runBAMRecalibration {
 cpus params.gatk.bamPostproc.cpus
 module 'gatk/3.3-0'

 input:
 genomeFile
 set runID, file(bamFile), file(baiFile) from realigned

 output:
 set file("${runID}.mkdup.ra.rc.*") into recalibratedAlignmentOut
 set runID, file("${runID}.mkdup.ra.rc.bam"), file("${runID}.mkdup.ra.rc.bai") into recalibratedAlignment

 """
 set -x
 # perform base recalibration, then print reads
 time java -Xmx8g org.broadinstitute.gatk.engine.CommandLineGATK -T BaseRecalibrator -R ${genomeFile} -knownSites ${params.dbSnp} -nct ${params.gatk.bamPostproc.cpus} -I ${bamFile} -o ${bamFile}.recal
 time java -Xmx8g org.broadinstitute.gatk.engine.CommandLineGATK -T PrintReads -R ${genomeFile} --BQSR ${bamFile}.recal -nct ${params.gatk.bamPostproc.cpus} -I ${bamFile} -o ${runID}.mkdup.ra.rc.bam
 """
}

copyHelper.copyFiles(recalibratedAlignmentOut, "bam")

// --------------------------------------------------------------------------
// Run Variant Calling on Postprocessed BAM File
// --------------------------------------------------------------------------

process runVariantCalling {
 cpus params.gatk.variantCalling.cpus
 module 'gatk/3.3-0'

 input:
 genomeFile
 set runID, file(bamFile), file(baiFile) from recalibratedAlignment

 output:
 file "*.vcf" into vcfOut

 script:mkdir
 """
 set -x
 ## call variants with GATK's UnifiedGenotyper
 #time java -Xmx64g org.broadinstitute.gatk.engine.CommandLineGATK -T UnifiedGenotyper -R ${genomeFile} -allowPotentiallyMisencodedQuals -glm BOTH --dbsnp ${params.dbSnp} -dcov 200 -I ${bamFile} -nct ${params.gatk.unifiedGenotyper.cpus} -o ${runID}.vcf
 # call variants with GATK's HaplotypeCaller and GenotypeGVCFs
 time java -Xmx64g org.broadinstitute.gatk.engine.CommandLineGATK -T HaplotypeCaller -R ${genomeFile} -nct ${params.gatk.haplotypeCaller.cpus} --emitRefConfidence GVCF --variant_index_type LINEAR --variant_index_parameter 128000 --dbsnp ${params.dbSnp} -I ${bamFile} -o ${runID}.g.vcf
 time java -Xmx64g org.broadinstitute.gatk.engine.CommandLineGATK -T GenotypeGVCFs -R ${genomeFile} -nt ${params.gatk.genotypeGVCFs.cpus} --dbsnp ${params.dbSnp} --variant ${runID}.g.vcf -o ${params.runID}.vcf
 """
}

copyHelper.copyFiles(vcfOut, "vcf");

}  // if (params.caller == "freebayes")
